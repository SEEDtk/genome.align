/**
 *
 */
package org.theseed.genome.align;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;

import org.kohsuke.args4j.Argument;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.theseed.basic.ParseFailureException;
import org.theseed.io.LineReader;
import org.theseed.utils.BaseReportProcessor;

/**
 * This command processes a groups.snips.tbl file generated by the GenomeAlignProcessor to determine the
 * number of changes per genome.  For each genome, it will output the number of upstream changes and the
 * number of instream changes.  It will also output the number of features that were changed in all
 * strains.
 *
 * The positional parameter is the name of the group snips file.
 *
 * The command-line options are as follows.
 *
 * -h	display command-line usage
 * -v	display more frequent log messages
 * -o	output file for report (if not STDIN)
 *
 * @author Bruce Parrello
 *
 */
public class SnipCountProcessor extends BaseReportProcessor {

    // FIELDS
    /** logging facility */
    protected static Logger log = LoggerFactory.getLogger(SnipCountProcessor.class);
    /** instream counters */
    private int[] inCounters;
    /** upstream counters */
    private int[] upCounters;
    /** map of genome IDs to names, in order */
    private LinkedHashMap<String, String> nameMap;
    /** number of all-genome upstream (0) and instream (1) changes */
    private int[] allCounters;

    // COMMAND-LINE OPTIONS

    /** input file name */
    @Argument(index = 0, metaVar = "groups.snips.tbl", usage = "group snips file name")
    private File inFile;

    @Override
    protected void setReporterDefaults() {
    }

    @Override
    protected void validateReporterParms() throws IOException, ParseFailureException {
        // Verify the input file.
        if (! this.inFile.canRead())
            throw new FileNotFoundException("Input file " + this.inFile + " is not found or unreadable.");
    }

    @Override
    protected void runReporter(PrintWriter writer) throws Exception {
        // Create the name map.
        this.nameMap = new LinkedHashMap<String, String>();
        this.allCounters = new int[2];
        Arrays.fill(this.allCounters,  0);
        // Now read the input file.
        try (LineReader inStream = new LineReader(this.inFile)) {
            // First we read the genome names into the name map.  This also gives us the column order.
            for (String[] line : inStream.new Section("//"))
                this.nameMap.put(line[0], line[1]);
            // Create the counters for the genomes.
            int nGenomes = this.nameMap.size();
            this.inCounters = new int[nGenomes];
            this.upCounters = new int[nGenomes];
            Arrays.fill(this.inCounters, 0);
            Arrays.fill(this.upCounters, 0);
            int[][] counters = new int[][] { this.upCounters, this.inCounters };
            // Next, we read the features.  Columns 3 through 11 contain the snip flags.
            for (String[] line : inStream.new Section(null)) {
                // Process upstream (0), then instream (1).
                for (int type = 0; type < 2; type++) {
                    int allCount = 0;
                    // Process each column.  We skip column 0, which is always blank.
                    for (int i = 1; i < nGenomes; i++) {
                        if (line[i+2].charAt(type) != ' ') {
                            allCount++;
                            counters[type][i]++;
                        }
                    }
                    // Update the appropriate all-counter.
                    if (allCount + 1 == nGenomes)
                        this.allCounters[type]++;
                }
            }
        }
        // Now the counts are all known.  Process each genome from the hash.  They will be output in the order
        // they are presented in the arrays.
        writer.println("genome_id\tgenome_name\tupstream_changes\tinstream_changes");
        int i = 0;
        for (Map.Entry<String, String> genomeEntry : this.nameMap.entrySet()) {
            String genomeId = genomeEntry.getKey();
            String genomeName = genomeEntry.getValue();
            writer.format("%s\t%s\t%d\t%d%n", genomeId, genomeName, this.upCounters[i], this.inCounters[i]);
            i++;
        }
        // Write the all-counters.
        writer.format("all\tMutations common to all engineered strains\t%d\t%d%n", this.allCounters[0], this.allCounters[1]);
    }

 }
